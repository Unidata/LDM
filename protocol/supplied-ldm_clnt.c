#include "config.h"
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "./ldm.h"
#include <errno.h>

/**
 * Returns the message associated with an LDM-7 status.
 *
 * @param[in] status  The LDM-7 status.
 * @return            The associated message.
 */
const char*
ldm7_errmsg(
 const int status)
{
 switch (status) {
 case LDM7_OK:
 return "Success";
 case LDM7_INTR:
 return "Interrupted by signal";
 case LDM7_TIMEDOUT:
 return "Transaction timed-out";
 case LDM7_RPC:
 return "RPC error";
 case LDM7_INVAL:
 return "Invalid argument";
 case LDM7_UNAUTH:
 return "Not authorized to receive multicast group";
 case LDM7_IPV6:
 return "IPv6 not supported";
 case LDM7_REFUSED:
 return "Connection refused by remote LDM-7";
 case LDM7_SYSTEM:
 return "System error";
 case LDM7_MCAST:
 return "Multicast error";
 case LDM7_SHUTDOWN:
 return "LDM-7 was shut down";
 default:
 return "Unknown status";
 }
}

int
clntStatusToLdm7Status(
 CLIENT* clnt)
{
 int status = clnt_stat((CLIENT*)clnt); // Safe cast
 if (status != 0) {
 if (status == RPC_TIMEDOUT) {
 status = LDM7_TIMEDOUT;
 }
 else if (status == RPC_SYSTEMERROR) {
 struct rpc_err rpcErr;
 clnt_geterr(clnt, &rpcErr);
 if (rpcErr.re_errno == ECONNREFUSED) {
 status = LDM7_REFUSED;
 }
 else {
 status = LDM7_SYSTEM;
 }
 }
 else if (status == RPC_AUTHERROR) {
 status = LDM7_UNAUTH;
 }
 else if (status == RPC_CANTRECV) {
 struct rpc_err rpcErr;
 clnt_geterr(clnt, &rpcErr);
 status = (rpcErr.re_errno == EINTR) ? LDM7_INTR : LDM7_RPC;
 }
 else {
 status = LDM7_RPC;
 }
 }
 return status;
}
#include <string.h>

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 60, 0 };
static const struct timeval ZERO_TIMEOUT = { 0, 0 };

fornme_reply_t *
feedme_6(feedpar_t *argp, CLIENT *clnt)
{
	static fornme_reply_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, FEEDME,
		(xdrproc_t) xdr_feedpar_t, (caddr_t) argp,
		(xdrproc_t) xdr_fornme_reply_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

fornme_reply_t *
notifyme_6(prod_class_t *argp, CLIENT *clnt)
{
	static fornme_reply_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, NOTIFYME,
		(xdrproc_t) xdr_prod_class_t, (caddr_t) argp,
		(xdrproc_t) xdr_fornme_reply_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

bool_t *
is_alive_6(u_int *argp, CLIENT *clnt)
{
	static bool_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, IS_ALIVE,
		(xdrproc_t) xdr_u_int, (caddr_t) argp,
		(xdrproc_t) xdr_bool, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

hiya_reply_t *
hiya_6(prod_class_t *argp, CLIENT *clnt)
{
	static hiya_reply_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HIYA,
		(xdrproc_t) xdr_prod_class_t, (caddr_t) argp,
		(xdrproc_t) xdr_hiya_reply_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
notification_6(prod_info *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, NOTIFICATION,
		(xdrproc_t) xdr_prod_info, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
hereis_6(product *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HEREIS,
		(xdrproc_t) xdr_product, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

comingsoon_reply_t *
comingsoon_6(comingsoon_args *argp, CLIENT *clnt)
{
	static comingsoon_reply_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, COMINGSOON,
		(xdrproc_t) xdr_comingsoon_args, (caddr_t) argp,
		(xdrproc_t) xdr_comingsoon_reply_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
blkdata_6(datapkt *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, BLKDATA,
		(xdrproc_t) xdr_datapkt, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

SubscriptionReply *
subscribe_7(McastSubReq *argp, CLIENT *clnt)
{
	static SubscriptionReply clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, SUBSCRIBE,
		(xdrproc_t) xdr_McastSubReq, (caddr_t) argp,
		(xdrproc_t) xdr_SubscriptionReply, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
request_product_7(McastProdIndex *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, REQUEST_PRODUCT,
		(xdrproc_t) xdr_McastProdIndex, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
request_backlog_7(BacklogSpec *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, REQUEST_BACKLOG,
		(xdrproc_t) xdr_BacklogSpec, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
test_connection_7(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, TEST_CONNECTION,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
deliver_missed_product_7(MissedProduct *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DELIVER_MISSED_PRODUCT,
		(xdrproc_t) xdr_MissedProduct, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
no_such_product_7(McastProdIndex *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, NO_SUCH_PRODUCT,
		(xdrproc_t) xdr_McastProdIndex, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
deliver_backlog_product_7(product *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DELIVER_BACKLOG_PRODUCT,
		(xdrproc_t) xdr_product, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
end_backlog_7(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, END_BACKLOG,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		ZERO_TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void*
nullproc_6(void *argp, CLIENT *clnt)
{
        static char clnt_res;
        if (clnt_call(clnt, NULLPROC,
                (xdrproc_t) xdr_void, (void*) argp,
                (xdrproc_t) xdr_void, (void*) &clnt_res,
                TIMEOUT) != RPC_SUCCESS) {
            return NULL;
        }
        return ((void *)&clnt_res);
}


enum clnt_stat clnt_stat(CLIENT *clnt)
{
    struct rpc_err rpcErr;

    clnt_geterr(clnt, &rpcErr);

    return rpcErr.re_status;
}
