CONTENTS OF THIS FILE
---------------------

* Introduction
* System Requirements
* Installation
* Usage
* Maintainers



INTRODUCTION
------------

FMTP is the third version of the reliable multicast transportation protocol
developed by University of Virginia. Currently, this protocol is running in
the user space as an application protocol. And underneath it's calling the
standard TCP/UDP and IP protocol stack. This protocol is consisted of two major
parts: the sending side and the receiving side. In a typical scenario, there
should be one sender and multiple receivers in a multicast group. The sender
runs the sending side protocol and sends out the data via multicast. Those
receivers will run the receiving side protocol to receive the data. If losses
happen, the receiver can request for retransmission via a TCP connection from
the receiver to the sender. And sender will determine either to respond to the
request or to reject it. Both the sender and receiver side have a timer thread.
The sender timer is used to form a window for legal retransmission and release
resources after the window is closed. And the receiver timer is used to watch
the EOPs. If it finds missing EOP, a requested will be sent back immediately.
The whole program is written in C++.
FMTP is integrated into LDM7 as an underlying layer. Also, a testing
application suite is provided as a simple replacement for LDM. The test
application provides product stream transmission. It reads the metadata of LDM
to replay the feedtype with exactly the same product size and inter-arrival
time. The only difference is that the content of a product is all 0.




SYSTEM REQUIREMENTS
-------------------

FMTP is developed and tested on Linux/UNIX. All the mainstream distributions
such as Ubuntu LTS 12.04 or above, CentOS 5 or above, Mac OSX 10.9 or above
and FreeBSD 9 or above will be supported. Microsoft Windows is not supported.

Recommended hardware for running this protocol would be:
* Duo core CPU or higher
* 1GB memory or higher
* 10GB hard drive or higher




INSTALLATION
------------

Before actually start to compile and install the protocol. Make sure the listed
pre-requisites have been met. All of the following instructions will be given
based on CentOS 6.6 x86_64. Here, only the instructions for installing FMTP
with test applications are provided. To use LDM along with FMTP, please see
LDM Tutorial (http://www.unidata.ucar.edu/software/ldm/ldm-current/tutorial/).

* Git
  $ sudo yum install git

* G++ 4.8 or above
  $ sudo yum install gcc-c++

* For Mac OS X users, Apple has been moved to LLVM, thus no default gcc is
  provided any more, you could use clang++ as an alternative.

* Next, for sending side, go into the sending protocol folder
  $ cd FMTP/sender
  $ make -f Makefile_send

* For receiving side, go into the receiving protocol folder
  $ cd FMTP/receiver
  $ make -f Makefile_recv

DEBUG and TEST flags
In the Makefile_send and Makefile_recv, there are DEBUG and TEST flags that
you can see. DEBUG flags are used with testing applications to print some
helpful statements for diagnosis. There are two different DEBUG flags which
is called the 2-level debug statements. If setting to DEBUG1, which means
DEBUG level 1 is enabled, only a statement indicating the sending and receiving
status on a per-product basis will be printed. If setting to DEBUG2, which means
DEBUG level 2 is enabled, detailed statements on a per-packet basis will be
printed to indicate the multicast and retransmission status of each block.
DEBUG1 flag will not generate log files, all the statements will only be
printed on the standard output. DEBUG2 flag will generate a log file as well
as posting all the statements to the standard output. A FMTP_SENDER.log will
be generated in fmtp/FMTP/sender/, a FMTP_RECEIVER.log will be generated
in fmtp/FMTP/receiver/
TEST flags are used to switch between different test cases. For example, if
TEST_BOP flag is set, the testSendApp will emulate the BOP-missing case.
Similarly, TEST_DATA_MISS enables emulation for data block missing case and
TEST_EOP enables emulation for EOP-missing case. On the other hand, if you just
want to do normal transmission, set TEST flag to NONE will be fine.

* To switch between those levels, simply open the makefile
  $ vi Makefile_send/Makefile_recv

* Comment the original flag and uncomment the new one (e.g.)
  DEBUG_FLAG = DEBUG1
  #DEBUG_FLAG = DEBUG2

* Likewise, for TEST flags, you can also do the same and switch among the flags.

MEASURE flags
Another flag embedded in the receiver code is the [MEASURE] flag. It helps to
gather statistic information like product reception time and received size.
With these statistics, users can write their own log parser to extract useful
information from the log (generated by the MEASURE code) and compute throughput
and file-delivery ratio and etc.

* To enable the MEASURE flag, just insert a new entry into the Makefile or
  uncomment the existing configuration.
  MEASURE_FLAG = MEASURE




USAGE
-----

FMTP is designed to cooperate with LDM (by UCAR) as an underlying transport
protocol. But it's also possible to work alone using the testing applications.
There is a testSendApp.cpp in the sender folder and a testRecvApp.cpp in the
receiver folder.
As being explained earlier, the testSendApp is the sending application which
plays the role of the single sender in a multicast group. And you can start as
many testRecvApp as you like to make them work as multicast receivers. But do
remember that the sender should always be started first before the receivers.
Both testSendApp and testRecvApp can receive command line arguments. So there
are two scripts to start the testapp with arguments respectively.

* Start the sender by
  $ ./startTestSendApp.sh

* Start the receiver by
  $ ./startTestRecvApp.sh

To make sender and receiver work, users should be aware under which scenario
they are trying to run the testapp. The first scenario is to run both sender
and receiver on the same node. With loopback enabled, it's possible to receive
the expected packets. Specifying the interface as the default one or 0.0.0.0
will work. Another scenario is two sides running on different nodes. Specifying
whatever interface on the node and the corresponding interface on the peer will
work. But pay attention that these interfaces should be physically connected.
If there is a mocked product queue and TTL needs to be non-one value,
developers can modify the testSendApp.cpp to call another fmtpSendv3()
constructor. The testSendApp has a built-in random sized product generator.
It reads the plain text file (which contains a single column of product sizes)
and parses that text file to extract each number as a size for a product. Then
it will read from system's /dev/urandom to fill a buffer of certain size as the
product to be sent. A sample input csv can be found at
https://github.com/shawnsschen/CC-NIE-Toolbox/blob/master/GENI/day1NGRID_400min.csv

To terminate the transmission, it is recommended to terminate the testRecvApp
first, or the other receivers could be affected if testSendApp is terminated
first instead.

APIs:
The sending side FMTP APIs include its constructor fmtpSendv3(), Start()
and sendProduct(). Applications should call the constructor first and call
Start() to start the preparation work. After that, applications can call
sendProduct() repeatedly to send products.
The receiving side FMTP APIs include constructor fmtpRecvv3(), Start()
and SetLinkSpeed(). Applications should first call the constructor and then
call SetLinkSpeed() to set the link rate. Then applications can call Start()
to receive data products.

Rate Shaper:
Since UDP doesn't handle flow control and congestion control. There should be
a way to limit the sending rate. Hence, the rate shaper is implemented as an
optional module to do application-layer rate shaping. By calling SetSendRate()
in the sending application with rate in bits per second as the only parameter,
FMTP will shaper the rate to the specified value on a per-packet basis, which
means sleeping intervals will be inserted between the transmission of two FMTP
packets. To disable this rate shaper, just do not call SetSendRate(), FMTP
will check if a valid rate is set. If not, then it implies there is some other
method applied for shaping the rate.

Silence Suppressor:
The original LDM feedtypes contain much silence. When replaying the metadata,
FMTP is sleeping on the silence period most of the time. In order to speed up
some tests (those don't strictly require an identical departure process), the
silence suppressor is implemented as an extra module. Every time FMTP sends a
product, it starts to wait for the inter-arrival time. However, it wakes up if
either all receivers have acknowledged this product or the sender side timer
expires. Either way, the product will be released and thus suppressing the
silence after this product would not harm the other products.
The silence suppressor constructs a product set of all the product indices it
is expecting. Once it receives a product, corresponding index will be erased
from the set. Its caller needs to decide whether to suppress the silence or
not based the return product index, which is oldest product not acknowledged,
from the silence suppressor.

TCP keepalive detection:
The receivers in a multicast group are joining and leaving dynamically. The
sender is responsible for tracking the status of all receivers (e.g. which ones
are offline). To do this, the sender makes use of the TCP keepalive probe
packets. When the transmission goes into silence for a while, TCP keepalive
will force a probe sent to connected receivers. The sender can then tell if
any receiver has dropped offline by the replied ACK. If an offline is detected
and it is not the last receiver in the multicast group, then the sender
silently closes the receiver-retransmission thread and remove the socket from
the connected list. Else if it is the last receiver, the sender throws an
exception and terminates.

In the silent case, the RetxMetadata still holds a copy of the offline socket.
This could cause the sender to believe a receiver has not ACKed and waits until
the timer expires. Also, when timer wakes up, a force EOP push to the unACKed
receiver will fail due to the invalid socket and lead to exception. To solve
this problem, in senderMetadata::clearUnfinishedSet() and notifyUnACKedRcvrs(),
the sender compares the unfinRcvr set against the most recent connected socket
list to find out the invalid offline receivers. And it takes action to erase
them.

Receiver verification:
For security concerns, FMTP performs strict access control upon receivers
connecting. The sender notifies the application of an incoming connection and
gets a true/false feedback on whether the receiver is allowed to connect.
The sender then takes corresponding action by adding/removing the receiver
from/into the connected list.

Path MTU Discovery:
To make effecient use of the network, FMTP will try to make full use of the
MTU payload. However, unlike a point-to-point connection, in a multicast
network, every receiver could have different path MTUs. FMTP has to track all
of the MTUs and use the minimum one for the multicast group. When a new
receiver is connected, the sender adjusts its minimum MTU value. When the
application calls the sender to send a new file, the sender can use the most
recent MTU for transmission.

Doxygen is also supported to generate various kinds of documentations. Now only
a HTML format document will be generated by doxygen. But if necessary, there is
a configuration file named fmtpdocs.conf which can be modified to enable other
outputs. To run doxygen generation process, do the following

$ doxygen fmtpdocs.conf

As the command is finished, a new folder named html will appear under current
path. You can use a browser to view the whole documentation.




MAINTAINERS
-----------

* Steve Emmerson, emmerson@ucar.edu,
  University Corporation for Atmospheric Research

* Shawn Chen, schen@virginia.edu,
  University of Virginia

* Ryan Aubrey, rma7qb@virginia.edu,
  University of Virginia
